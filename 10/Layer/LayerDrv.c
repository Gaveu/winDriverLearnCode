#include<ntddk.h>

typedef struct _DEVICE_EXTENSION
{
	PDEVICE_OBJECT TargetDevice;
}DEVICE_EXTENSION, *PDEVICE_EXTENSION;

VOID Unload(IN PDRIVER_OBJECT DriverObject)
{
	PDEVICE_EXTENSION pDevExtension = (PDEVICE_EXTENSION)DriverObject->DeviceObject->DeviceExtension;
	
	//返还目标设备对象，卸载分层过滤设备对象
	ObDereferenceObject(pDevExtension->TargetDevice);
	IoDeleteDevice(DriverObject->DeviceObject);

	KdPrint(("Goodbye LayerDriver!\n"));
}

NTSTATUS DispatchRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
	static PCHAR irpType[] =
	{
		"IRP_MJ_CREATE					",
		"IRP_MJ_CREATE_NAMED_PIPE		",
		"IRP_MJ_CLOSE					",
		"IRP_MJ_READ					",
		"IRP_MJ_WRITE					",
		"IRP_MJ_QUERY_INFORMATION		",
		"IRP_MJ_SET_INFORMATION			",
		"IRP_MJ_QUERY_EA				",
		"IRP_MJ_SET_EA					",
		"IRP_MJ_FLUSH_BUFFERS			",
		"IRP_MJ_QUERY_VOLUME_INFORMATION",
		"IRP_MJ_SET_VOLUME_INFORMATION	",
		"IRP_MJ_DIRECTORY_CONTROL		",
		"IRP_MJ_FILE_SYSTEM_CONTROL		",
		"IRP_MJ_DEVICE_CONTROL			",
		"IRP_MJ_INTERNAL_DEVICE_CONTROL	",
		"IRP_MJ_SHUTDOWN				",
		"IRP_MJ_LOCK_CONTROL			",
		"IRP_MJ_CLEANUP					",
		"IRP_MJ_CREATE_MAILSLOT			",
		"IRP_MJ_QUERY_SECURITY			",
		"IRP_MJ_SET_SECURITY			",
		"IRP_MJ_POWER					",
		"IRP_MJ_SYSTEM_CONTROL			",
		"IRP_MJ_DEVICE_CHANGE			",
		"IRP_MJ_QUERY_QUOTA				",
		"IRP_MJ_SET_QUOTA				",
		"IRP_MJ_PNP						",
		"IRP_MJ_PNP_POWER				",
		"IRP_MJ_MAXIMUM_FUNCTION		"
	};
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	KdPrint(("Layer:%s hit!\n", irpType[stack->MajorFunction]));

	Irp->IoStatus.Information = 0;
	Irp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}

NTSTATUS DispatchRead(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
	PDEVICE_EXTENSION pDevEtn = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
	NTSTATUS status;
	KdPrint(("Layer:IRP_MJ_READ In!\n"));
	
	//跳过对当前IRP的处理
	IoSkipCurrentIrpStackLocation(Irp);

	//将当前IRP交付给目标驱动执行，并将状态值结果返回至status中
	status = IoCallDriver(pDevEtn->TargetDevice, Irp);

	KdPrint(("Layer:IRP_MJ_READ Back!\n"));
	return status;
}

NTSTATUS DispatchWrite(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
	PDEVICE_EXTENSION pDevEtn = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
	NTSTATUS status;
	KdPrint(("Layer:IRP_MJ_WRITE In!\n"));

	//跳过对当前IRP的处理
	IoSkipCurrentIrpStackLocation(Irp);

	//将当前IRP交付给目标驱动执行，并将状态值结果返回至status中
	status = IoCallDriver(pDevEtn->TargetDevice, Irp);

	KdPrint(("Layer:IRP_MJ_WRITE Back!\n"));
	return status;
}

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
	int i;
	NTSTATUS status;
	PDEVICE_OBJECT LayerDeviceObject;
	PDEVICE_EXTENSION pDevExtension;
	PDEVICE_OBJECT TargetDeviceObject;
	PFILE_OBJECT FileObject;
	
	KdPrint(("Hello LayerDriver!\n"));
	DriverObject->DriverUnload = Unload;

	//目标驱动设备名
	UNICODE_STRING TargetDeviceName = RTL_CONSTANT_STRING(L"\\Device\\BufferIO");
	UNICODE_STRING LayerDeviceName = RTL_CONSTANT_STRING(L"\\Device\\LayerDev");

	//创建分层过滤的设备对象
	status = IoCreateDevice(
		DriverObject,
		sizeof(DEVICE_EXTENSION),
		&LayerDeviceName,
		FILE_DEVICE_UNKNOWN,
		FILE_AUTOGENERATED_DEVICE_NAME,
		FALSE,
		&LayerDeviceObject
		);
	if (!NT_SUCCESS(status))
	{
		KdPrint(("Layer Device Create Failed!\n"));
		return status;
	}

	//根据目标驱动的设备对象名,获取对应设备对象
	status = IoGetDeviceObjectPointer(
		&TargetDeviceName,
		FILE_ANY_ACCESS,
		&FileObject,
		&TargetDeviceObject
		);
	if (!NT_SUCCESS(status))
	{
		KdPrint(("TargetDeviceObject Get Failed!\n"));
		IoDeleteDevice(LayerDeviceObject);
		return status;
	}

	//配置设备扩展,便于备份目标设备对象的指针变量
	pDevExtension = (PDEVICE_EXTENSION)LayerDeviceObject->DeviceExtension;

	//令分层过滤驱动的设备对象堆叠到目标设备对象的上层
	pDevExtension->TargetDevice = IoAttachDeviceToDeviceStack(
		LayerDeviceObject,	//待叠加的上层设备对象
		TargetDeviceObject	//被叠加的下层设备对象
		);

	//配置分层过滤驱动的设备对象参数，部分需要与目标设备对象一致
	LayerDeviceObject->Characteristics = pDevExtension->TargetDevice->Characteristics;
	LayerDeviceObject->DeviceType = pDevExtension->TargetDevice->DeviceType;
	LayerDeviceObject->Flags = pDevExtension->TargetDevice->Flags;
	LayerDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
	
	//配置分层过滤驱动的派遣函数
	//所有除IRP_MJ_READ、IRP_MJ_WRITE外的IRP由分层过滤驱动的DispatchRoutine处理
	//IRP_MJ_READ、IRP_MJ_WRITE的IRP由目标驱动处理
	for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; ++i)
	{
		if (IRP_MJ_READ == i)
		{
			DriverObject->MajorFunction[i] = DispatchRead;
		}
		else if (IRP_MJ_WRITE == i)
		{
			DriverObject->MajorFunction[i] = DispatchWrite;
		}
		else
		{
			DriverObject->MajorFunction[i] = DispatchRoutine;
		}
	}


	//返还文件对象
	ObDereferenceObject(FileObject);

	return STATUS_SUCCESS;
}